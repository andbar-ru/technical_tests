package entities

import (
	"strings"
	"time"
)

// A Date represents Time but trancates time by itself.
type Date struct {
	time.Time
}

// UnmarshalJSON overrides time.Time.UnmarshalJSON. Also lets to send dates without time in
// format 2006-01-02. Resets time when saves.
func (d *Date) UnmarshalJSON(data []byte) error {
	var t time.Time
	err := t.UnmarshalJSON(data)
	if err == nil {
		d.Time = time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, time.UTC)
		return nil
	}
	if _, ok := err.(*time.ParseError); !ok {
		return err
	}
	s := strings.Trim(string(data), `"`)
	t, err = time.Parse(time.DateOnly, s)
	if err != nil {
		return err
	}
	d.Time = t
	return nil
}

// String returns date without time in format 2006-01-02.
func (d Date) String() string {
	return d.Time.Format(time.DateOnly)
}

// An Order represents order.
type Order struct {
	// Identifier
	ID string `json:"id"`
	// Hotel identifier
	HotelID string `json:"hotel_id"`
	// Room kind identifier
	RoomID string `json:"room_id"`
	// User email
	UserEmail string `json:"email"`
	// Start date
	From Date `json:"from"`
	// End date
	To Date `json:"to"`
}

// Validate validates the Order and returns slice of errors if Order is not valid.
func (o Order) Validate() []error {
	var errs []error
	var zeroOrder Order
	if o.ID == zeroOrder.ID {
		errs = append(errs, AppError{"Field 'id' is not specified"})
	}
	if o.HotelID == zeroOrder.HotelID {
		errs = append(errs, AppError{"Field 'hotel_id' is not specified"})
	}
	if o.RoomID == zeroOrder.RoomID {
		errs = append(errs, AppError{"Field 'room_id' is not specified"})
	}
	if o.UserEmail == zeroOrder.UserEmail {
		errs = append(errs, AppError{"Field 'email' is not specified"})
	}
	if o.From == zeroOrder.From {
		errs = append(errs, AppError{"Field 'from' is not specified"})
	}
	if o.To == zeroOrder.To {
		errs = append(errs, AppError{"Field 'to' is not specified"})
	}
	if o.From.After(o.To.Time) {
		errs = append(errs, AppError{"Date 'from' is later than date 'to'"})
	}
	return errs
}

// Days returns the days between the dates "From" and "To" including them.
func (o Order) Days() []Date {
	if o.From.After(o.To.Time) {
		return nil
	}
	days := make([]Date, 0)
	curDay := o.From
	for !curDay.After(o.To.Time) {
		days = append(days, curDay)
		curDay = Date{Time: curDay.AddDate(0, 0, 1)}
	}
	return days
}

// A RoomAvailability represents a number of available rooms in hotels.
type RoomAvailability struct {
	// Identifier
	ID string `json:"id"`
	// Hotel identifier
	HotelID string `json:"hotel_id"`
	// Room identifier
	RoomID string `json:"room_id"`
	// Date
	Date Date `json:"date"`
	// Number of available rooms on date Date
	Quota int `json:"quota"`
}

// An AppError represents an error which is generated by app to discriminate app errors from library errors.
type AppError struct {
	// Error message
	Message string
}

// Error return string representation of AppError.
func (e AppError) Error() string {
	return e.Message
}
